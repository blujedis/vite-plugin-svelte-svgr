{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAyB;AACzB,sBAAwB;AACxB,kBAAoE;AAGpE,yBAA6B;AAE7B,IAAM,EAAE,aAAa;AAErB,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AACvB,IAAM,gBAAgB;AACtB,IAAM,WAA0B;AAAA,EAC9B,MAAM;AACR;AACA,IAAM,gBAAiC,CAAC;AAExC,IAAM,QAAQ,oBAAI,IAAI;AAOtB,yBAAyB,MAAsB;AAE7C,QAAM,QAAQ,cAAc,KAAK,IAAI;AAErC,MAAI,CAAC;AACH,UAAM,IAAI,MAAM,kCAAkC;AAEpD,QAAM,CAAC,EAAE,MAAM,QAAQ;AACvB,SAAO,GAAG,oBAAoB;AAEhC;AAMA,qBAAqB,KAAqC;AACxD,SAAO,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAE,WAAU;AAChE;AAOA,oBAAoB,OAAsB,EAAE,MAAM,YAAY,GAAW;AAEvE,SAAO;AAAA,IACL,GAAG;AAAA,IACH,GAAG;AAAA,EACL;AAEA,QAAM,iBAAiB,CAAC,CAAC,KAAK,QAAQ,OAAO,KAAK,SAAS;AAC3D,MAAI,cAAe,KAAK,QAAQ,CAAC;AACjC,gBAAc,gBAAgB,OAAO,EAAE,GAAG,cAAc,IAAI;AAE5D,MAAI;AAEJ,MAAI,KAAK,WAAW,KAAK;AACvB,aAAS,qCAAa,KAAK,SAAS,KAAK,SAAS,EAAE,SAAS,KAAK,KAAK,CAAC;AAE1E,SAAO;AAAA,IAEL,MAAM;AAAA,IAEN,MAAM,UAAU,KAAa,IAAY,SAAS;AAEhD,YAAM,QAAQ,GAAG,MAAM,aAAa;AAGpC,UAAI,CAAE,UAAS,CAAC,GAAG,UAAW,UAAU,CAAC,OAAO,EAAE;AAChD,eAAO;AAET,YAAM,QAAQ,mCAAS;AAEvB,UAAI,OAAO;AAIT,cAAM,OAAQ,MAAM,MAAM,KAAK;AAG/B,YAAI,QAAQ,SAAS;AACnB,iBAAO;AAET,YAAI;AAEF,gBAAM,UAAU,GAAG,MAAM;AACzB,gBAAM,SAAS,MAAM,IAAI,OAAO;AAEhC,cAAI;AACF,mBAAO;AAET,gBAAM,WAAW,GAAG,QAAQ,gBAAgB,MAAM;AAElD,cAAI,OAAQ,OAAM,SAAS,QAAQ,GAAG,SAAS,OAAO;AAEtD,gBAAM,YAAY,iBACd,0BAAS,MAAM,EAAE,GAAG,aAAa,MAAM,SAAS,CAAC,IACjD,EAAE,KAAK;AAEX,cAAI,YAAY,SAAS,GAAG;AAC1B,oBAAQ,MAAM,iCAAiC,SAAS;AACxD,mBAAO;AAAA,UACT;AAGA,cAAI,SAAS,OAAO;AAClB,mBAAO;AAAA,mBAAsB,UAAU;AAAA,UACzC,OAGK;AAEH,sBAAU,OAAO,gBAAgB,UAAU,IAAI;AAE/C,kBAAM,EAAE,OAAO,6BAAQ,UAAU,MAAM;AAAA,cACrC,KAAK;AAAA,cACL,UAAU;AAAA,cACV,YAAY;AAAA,cACZ,WAAW;AAAA,cACX,UAAU,QAAQ,QAAQ;AAAA,YAC5B,CAAC;AAED,mBAAO,GAAG;AACV,mBAAO;AAAA,UACT;AAGA,gBAAM,IAAI,SAAS,IAAI;AAEvB,iBAAO;AAAA,QAET,SAEO,KAAP;AACE,gBAAM,EAAE,UAAU;AAClB,gBAAM,UAAU,yBAAyB;AACzC,kBAAQ,MAAM,GAAG;AAAA,EAAY,OAAO;AAAA,QACtC;AAAA,MACF;AAEA,aAAO;AAAA,IAET;AAAA,EAEF;AAEF;AAIA,IAAO,cAAQ","sourcesContent":["import { promises } from 'fs';\nimport { compile } from 'svelte/compiler';\nimport { optimize, type OptimizedError, type OptimizeOptions } from 'svgo';\nimport { Plugin } from 'vite';\nimport { PluginOptions, SvgType } from './types';\nimport { createFilter } from '@rollup/pluginutils';\n\nconst { readFile } = promises;\n\nconst SVG_PARTS_EXP = /(<svg.*?)(>.*)/s;\nconst SVG_SUFFIX_EXP = /\\.svg(\\?.*)$/;\nconst SVG_MATCH_EXP = /\\.svg(?:\\?(raw|url|component))?$/;\nconst DEFAULTS: PluginOptions = {\n  type: 'component'\n};\nconst SVGO_DEFAULTS: OptimizeOptions = {};\n\nconst cache = new Map();\n\n/**\n * Extends SVG with props.\n * \n * @param data the data to be extended with prop.\n */\nfunction extendWithProps(data: string): string {\n\n  const parts = SVG_PARTS_EXP.exec(data);\n\n  if (!parts)\n    throw new Error('Data is not a valid SVG element.');\n\n  const [, head, body] = parts;\n  return `${head} {...$$props}${body}`;\n\n}\n\n/**\n * If no data in payload then it is likely an Opti\n * @param err the error object to inspect as Optimize Error.  \n */\nfunction isSVGOError(err: unknown): err is OptimizedError {\n  return typeof err === 'object' && err !== null && !('data' in err)\n}\n\n/**\n * Initializes the plugin instance.\n * \n * @param options vite plugin svelte svgr global options.\n */\nfunction initPlugin(opts: PluginOptions = { type: 'component' }): Plugin {\n\n  opts = {\n    ...DEFAULTS,\n    ...opts\n  };\n\n  const shouldOptimize = !!opts.svgo || typeof opts.svgo === 'undefined';\n  let svgoOptions = (opts.svgo || {}) as OptimizeOptions;\n  svgoOptions = svgoOptions === true ? { ...SVGO_DEFAULTS } : svgoOptions;\n\n  let filter: ReturnType<typeof createFilter> | undefined;\n\n  if (opts.include || opts.exclude)\n    filter = createFilter(opts.include, opts.exclude, { resolve: opts.root });\n\n  return {\n\n    name: 'svelte-svgr',\n\n    async transform(src: string, id: string, options) {\n\n      const match = id.match(SVG_MATCH_EXP);\n\n      // Not a match nothing to do.\n      if (!(match || []).length || (filter && !filter(id)))\n        return null;\n\n      const isSSR = options?.ssr;\n\n      if (match) {\n\n\n        // Defer to param type, fallback to type defined in options if any.\n        const type = (match[1] || opts.type) as SvgType;\n\n        // Return the url of the SVG.\n        if (type && type === 'url')\n          return src;\n\n        try {\n\n          const cacheid = `${id}:${isSSR}`;\n          const cached = cache.get(cacheid);\n\n          if (cached)\n            return cached;\n\n          const filename = id.replace(SVG_SUFFIX_EXP, '.svg');\n\n          let data = (await readFile(filename)).toString('utf-8');\n\n          const optimized = shouldOptimize\n            ? optimize(data, { ...svgoOptions, path: filename })\n            : { data };\n\n          if (isSVGOError(optimized)) {\n            console.error(\"Got optimize error from SVGO:\", optimized)\n            return undefined;\n          }\n\n          // Return raw optimized SVG.\n          if (type === 'raw') {\n            data = `\\nexport default \\`${optimized.data}\\`;`;\n          }\n\n          // Default to componentized SVG.\n          else {\n\n            optimized.data = extendWithProps(optimized.data);\n\n            const { js } = compile(optimized.data, {\n              css: false,\n              filename: id,\n              hydratable: true,\n              namespace: 'svg',\n              generate: isSSR ? 'ssr' : 'dom',\n            });\n\n            delete js.map;\n            data = js;\n          }\n\n          // Cache the optimized transformed SVG.\n          cache.set(cacheid, data);\n\n          return data;\n\n        }\n\n        catch (err: unknown) {\n          const { stack } = err as Error;\n          const message = `Failed to read SVG at ${id}`;\n          console.error(`${message}\\n${stack}`);\n        }\n      }\n\n      return null;\n\n    }\n\n  };\n\n}\n\nexport * from './types';\n\nexport default initPlugin;\n"]}